â€ƒâ€ƒChemiQæ˜¯åœ¨é‡å­è®¡ç®—æœºæˆ–è™šæ‹Ÿæœºä¸Šæ¨¡æ‹ŸåŒ–å­¦åˆ†å­ç»“æ„å’Œæ€§è´¨çš„ä»¿çœŸè½¯ä»¶â€”â€”ä¹Ÿæ˜¯å…¨çƒé¦–æ¬¾è¿ç”¨é‡å­ç®—æ³•æ¨¡æ‹Ÿçš„ä»¿çœŸè½¯ä»¶â€”â€”æ¥å…¥é‡å­è®¡ç®—æœºè®¡ç®—é€Ÿåº¦å‘ˆæŒ‡æ•°å¢é•¿ã€‚ChemiQåˆ©ç”¨Jordan-Wignerï¼ŒParityç­‰æ–¹æ³•å°†äºŒæ¬¡é‡å­åŒ–çš„Fermionçš„Hamiltonianç®—ç¬¦è½¬åŒ–ï¼ˆmappingï¼‰æˆQubitçš„Hamiltonianç®—ç¬¦ï¼ˆé‡å­è®¡ç®—æœºè¯†åˆ«çš„ç®—ç¬¦ï¼‰ï¼Œç®—ç¬¦é—´çš„è½¬æ¢æ˜¯é‡å­è®¡ç®—æ¨¡æ‹ŸåŒ–å­¦è¿‡ç¨‹çš„ç¬¬ä¸€æ­¥ï¼Œä¸åŒçš„è½¬åŒ–æ–¹æ³•å¯¹åº”ç€ä¸åŒçš„Qubitä¿¡æ¯ï¼Œç ”ç©¶å‡ºæ‰€è½¬åŒ–çš„ç®—ç¬¦å°‘çš„mappingï¼Œç›¸åº”çš„è®¡ç®—å°‘ï¼Œå¯å¤§å¤§ç®€åŒ–è®¡ç®—ï¼›ä½¿ç”¨Unitary Coupled Clusterï¼ˆç®€ç§°UCCï¼‰ç­‰æ‹Ÿè®¾æ„é€ æ¨¡æ‹Ÿé‡å­ç”µè·¯ï¼Œåˆ†åˆ«ä»£è¡¨ä¸åŒçš„ç”µè·¯æ¨¡å‹ï¼Œæ‰€åŒ…å«çš„å‚æ•°æ•°ç›®å’Œçº¿è·¯æ·±åº¦ä¹Ÿä¸å°½ç›¸åŒï¼Œæ„é€ å‡ºå‚æ•°å°‘ã€çº¿è·¯æµ…çš„çº¿è·¯æ‹Ÿè®¾æ˜¯é‡å­è®¡ç®—æ¨¡æ‹Ÿçš„å…³é”®ï¼Œä½¿å¾—å¤æ‚çš„åŒ–å­¦è¿‡ç¨‹å¾—åˆ°æœ‰æ•ˆæ¨¡æ‹Ÿï¼›å†ç»“åˆé‡å­ç›¸ä½è¯„ä¼°ï¼ˆQPEï¼‰ï¼Œå˜åˆ†é‡å­æœ¬å¾æ±‚è§£ï¼ˆVQEï¼‰ç®—æ³•ï¼Œæˆ–é‡å­è™šæ—¶æ¼”åŒ–ï¼ˆQITEï¼‰ç®—æ³•æ¨¡æ‹Ÿåˆ†å­å“ˆå¯†é¡¿é‡çš„æœŸæœ›å€¼ï¼Œè¿›ä¸€æ­¥é¢„æµ‹åˆ†å­æ€§è´¨ã€‚è¿™äº›ç®—æ³•ä¸ä»…èƒ½ä¿è¯é‡å­æ€çš„ç›¸å¹²æ€§ï¼Œå…¶è®¡ç®—ç»“æœè¿˜èƒ½è¾¾åˆ°åŒ–å­¦ç²¾åº¦ï¼Œåœ¨å¯é¢„è§çš„æœªæ¥ï¼Œæœ‰ç€æå¤§çš„åº”ç”¨å‰æ™¯å’Œä¼˜åŠ¿ã€‚


.. image:: ./images/å›¾é™„3.1.0.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.1 ChemiQè½¯ä»¶

3.1 ChemiQåŒ–å­¦è½¯ä»¶çš„å®‰è£…
==================================

â€ƒâ€ƒ1ã€ç™»å½•æœ¬æºé‡å­äº‘å®˜ç½‘å›¾é™„3.1.1.pngï¼ˆhttps://qcloud.originqc.com.cn/ï¼‰ï¼Œé€‰æ‹©â€œåº”ç”¨æ¨å¹¿äº‘â€ï¼Œå¦‚å›¾é™„3.1.2 æ‰€ç¤ºï¼›é€‰æ‹©â€œç”Ÿç‰©åŒ»è¯â€æ–¹å‘ï¼Œç‚¹å‡»â€œäº†è§£è¯¦æƒ…â€å¦‚å›¾é™„3.1.3æ‰€ç¤ºï¼›ç‚¹å‡»â€œWindowsè¿›è¡Œä¸‹è½½â€ï¼Œå¦‚å›¾é™„3.1.4æ‰€ç¤ºã€‚ï¼ˆç›´è¾¾é¡µé¢ï¼šhttps://qcloud.originqc.com.cn/chemistryIntroduceï¼‰

.. image:: ./images/å›¾é™„3.1.1.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.2 é€‰æ‹©â€œåº”ç”¨æ¨å¹¿äº‘â€

.. image:: ./images/å›¾é™„3.1.2.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.3 é€‰æ‹©â€œç”Ÿç‰©åŒ»è¯â€

.. image:: ./images/å›¾é™„3.1.3.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.4 ä¸‹è½½

â€ƒâ€ƒ2ã€ä¸‹è½½å®Œæˆåï¼ŒåŒå‡»å®‰è£…è¯¥è½¯ä»¶ï¼Œç‚¹å‡»â€œæˆ‘åŒæ„â€ï¼›

.. image:: ./images/å›¾é™„3.1.4.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.5 ç‚¹å‡»â€œæˆ‘åŒæ„â€

â€ƒâ€ƒ3ã€ç„¶åç‚¹å‡»â€œä¸‹ä¸€æ­¥â€ï¼›

.. image:: ./images/å›¾é™„3.1.5.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.6 ä¸‹ä¸€æ­¥

â€ƒâ€ƒ4ã€å†å®‰è£…åˆ°é»˜è®¤ç›®å½•ï¼Œç‚¹å‡»â€œå®‰è£…â€ï¼›

.. image:: ./images/å›¾é™„3.1.6.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.7 ç‚¹å‡»â€œå®‰è£…â€

â€‹â€ƒâ€ƒ5ã€å®‰è£…å®Œæˆåï¼Œè¿è¡Œè¯¥è½¯ä»¶ã€‚

.. image:: ./images/å›¾é™„3.1.7.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.1.8 å®‰è£…å®Œæˆ


3.2 ChemiQè½¯ä»¶åº”ç”¨ç¤ºä¾‹
===================================

â€‹â€ƒâ€ƒ1ã€ æ–°å»ºé¡¹ç›®ã€‚å…ˆæ–°å»ºä¸€ä¸ªé¡¹ç›®åç§°â€”â€”test H2ï¼Œç„¶åæ˜¯å¡«å¥½åˆ›å»ºäººã€è®¡ç®—æ¨¡å¼ã€ä¿å­˜è·¯å¾„å’Œé¡¹ç›®æè¿°ï¼Œæœ€åç‚¹å‡»ç¡®å®šã€‚

.. image:: ./images/å›¾é™„3.1.8.bmp
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.2.1 æ–°å»ºé¡¹ç›®

â€‹â€ƒâ€ƒ2ã€ ä¸»ç•Œé¢ã€‚è¯¥è½¯ä»¶å·¦ä¾§æ˜¾ç¤ºçš„æ˜¯é¡¹ç›®ä¸‹çš„ä»»åŠ¡åˆ—è¡¨ï¼›å·¦ä¸‹æ˜¾ç¤ºçš„æ˜¯é¡¹ç›®æˆ–è€…ä»»åŠ¡è¯¦æƒ…ï¼›å³ä¾§æ˜¾ç¤ºåˆ†ä¸ºä¸Šä¸‹ä¸¤éƒ¨åˆ†ï¼Œä¸Šéƒ¨åˆ†ä¸ºåˆ†å­æ¨¡å‹ï¼Œä¸‹éƒ¨åˆ†ä¸ºç»“æœå±•ç¤ºï¼Œå¯ä¸Šä¸‹æ‹–åŠ¨è°ƒèŠ‚å¤§å°ã€‚

.. image:: ./images/å›¾é™„3.1.9.bmp
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.2.2 ä¸»é¡µé¢


â€‹â€ƒâ€ƒ3ã€ åˆ†å­å»ºæ¨¡ã€‚ä»¥æ°¢åˆ†å­åŠ¿èƒ½æ›²çº¿ä¸ºä¾‹ï¼Œé¦–å…ˆæ˜¯æ„å»ºåˆ†å­æ¨¡å‹ã€‚ç‚¹å‡»è®¾ç½®-åˆ†å­æ¨¡å‹ï¼Œæˆ–è€…å·¥å…·æ ä¸­å›¾æ ‡æ„å»ºåˆ†å­æ¨¡å‹ã€‚åœ¨è¿™é‡Œå¯ä½¿ç”¨æ„å»ºåˆ†å­å¿«æ·å·¥å…·ï¼Œå¦‚å³ä¾§å¼¹å‡ºæ¡†ã€‚

.. image:: ./images/å›¾é™„3.1.10.bmp
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.2.3 åˆ†å­å»ºæ¨¡

â€‹â€ƒâ€ƒ4ã€ é…ç½®å‚æ•°ã€‚åœ¨å‚æ•°é…ç½®æ¡†ä¸­é€‰æ‹©è®¡ç®—ç±»å‹â€”â€”åŠ¿èƒ½æ›²çº¿ï¼ŒåŸºç»„ã€ç”µè·ã€è‡ªæ—‹å¤šé‡åº¦å¯æ ¹æ®ç”¨æˆ·å¯¹åº”è®¾ç½®ï¼Œåœ¨è¿™é‡Œä»¥STO-3GåŸºç»„æ¨¡æ‹Ÿæ°¢åˆ†å­PESï¼›æ‰«æåæ ‡é€‰æ‹©æ°¢åˆ†å­ä¸­é”®é•¿è·ç¦»ä¸ºå˜é‡ï¼Œè®¾ç½®å¯¹åº”çš„èŠ‚ç‚¹ä¸ªæ•°å’Œæ‰«æåŒºé—´ï¼›æ˜ å°„ã€æ‹Ÿè®¾å’Œä¼˜åŒ–å™¨å¯¹åº”é€‰æ‹©å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

.. image:: ./images/å›¾é™„3.1.11.bmp
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.2.4 é…ç½®å‚æ•°

â€‹â€ƒâ€ƒ5ã€ä»»åŠ¡è¯¦æƒ…ã€‚å·¦ä¸‹éƒ¨åˆ†æ˜¾ç¤ºä»»åŠ¡çš„å‚æ•°è¯¦æƒ…ï¼Œå¦‚è®¡ç®—ç»“æœä¸­å±•ç¤ºçš„è®¡ç®—åˆ—è¡¨ï¼Œå…¶ä¸­å¾€ä¸‹æ‹‰ä¼šæ˜¾ç¤º20ä¸ªèŠ‚ç‚¹ä»»åŠ¡ï¼›æ­¤å¤–ä¸ºäº†ä¾¿äºæ˜¾ç¤ºï¼Œå¯ç‚¹å‡»è§†å›¾ä¸­ä¾¿æ·å·¥å…·ï¼Œå¦‚å›¾å±•ç¤ºæ˜¯åˆ†å­æ¨¡å‹ä¸­çš„å…ƒç´ åç§°å’Œå…ƒç´ ç¼–å·ã€‚

.. image:: ./images/å›¾é™„3.1.12.bmp
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.2.5 ä»»åŠ¡è¯¦æƒ…

â€‹â€ƒâ€ƒ6ã€ è®¡ç®—å®Œæˆã€‚å¯ä»¥çœ‹åˆ°è®¡ç®—ç»“æœå·²ç»å±•ç¤ºå‡ºæ¥ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥çœ‹åˆ°æ¯ä¸ªæ°¢åˆ†å­åæ ‡è®¡ç®—å¾—åˆ°èƒ½é‡å¦‚ä¸‹ï¼š

.. image:: ./images/å›¾é™„3.1.13.bmp
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.2.6 è®¡ç®—å®Œæˆ

â€‹â€ƒâ€ƒ7ã€ ç»“æœå±•ç¤ºã€‚åŠ¿èƒ½æ›²çº¿ä¸­å¯ç‚¹å‡»å•ä¸ªèŠ‚ç‚¹è¿›å…¥ç»“æœè¯¦æƒ…ä¸­ï¼Œæˆ–è€…ç‚¹å‡»è®¡ç®—åˆ—è¡¨/åŠ¿èƒ½æ›²çº¿åˆ‡æ¢ç»“æœå±•ç¤ºã€‚

.. image:: ./images/å›¾é™„3.1.14.bmp
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.2.7 ç»“æœå±•ç¤º

3.3  ChemiQæ¥å£ä»‹ç»ä¸ä½¿ç”¨
=======================================

**ä½¿ç”¨å°è£…çš„ChemiQè®¡ç®—æ¥å£è¿›è¡Œå®ç°**

â€ƒâ€ƒè¡¨é™„3.3.1ï¼Œåˆ—å‡ºçš„æ˜¯ChemiQå°è£…çš„è®¡ç®—æ¥å£ï¼š

.. centered:: è¡¨é™„3.3.1
.. list-table::
    :align: center

    * - **æ¥å£åç§°**
      - **æè¿°**
    * - initialize
      - åˆå§‹åŒ–é‡å­åŒ–å­¦è®¡ç®—çš„ç¯å¢ƒ
    * - finalize
      - é‡Šæ”¾é‡å­åŒ–å­¦è®¡ç®—çš„ç¯å¢ƒ
    * - setMolecule
      - è®¾ç½®å•ä¸ªåˆ†å­æ¨¡å‹
    * - setMolecules
      - è®¾ç½®ä¸€ç»„åˆ†å­æ¨¡å‹
    * - setMultiplicity
      - è®¾ç½®é‡æ•°
    * - setCharge
      - è®¾ç½®ç”µè·æ•°
    * - setBasis
      - è®¾ç½®è®¡ç®—åŸº
    * - setTransformType
      - è®¾ç½®è´¹ç±³å­åˆ°æ³¡åˆ©ç®—å­çš„è½¬æ¢ç±»å‹
    * - setUccType
      - è®¾ç½®UCCæ¨¡å‹ç±»å‹
    * - setOptimizerType
      - è®¾ç½®ä¼˜åŒ–å™¨ç±»å‹
    * - setOptimizerIterNum
      - è®¾ç½®ä¼˜åŒ–å™¨è¿­ä»£æ¬¡æ•°
    * - setOptimizerFuncCallNum
      - è®¾ç½®ä¼˜åŒ–å™¨å‡½æ•°è°ƒç”¨æ¬¡æ•°
    * - setOptimizerXatol
      - è®¾ç½®ä¼˜åŒ–å™¨å‚æ•°æ”¶æ•›é˜ˆå€¼
    * - setOptimizerFatol
      - è®¾ç½®ä¼˜åŒ–å™¨å‡½æ•°æ”¶æ•›é˜ˆå€¼
    * - setLearningRate
      - è®¾ç½®å­¦ä¹ ç‡
    * - setEvolutionTime
      - è®¾ç½®æ¼”åŒ–æ—¶é—´
    * - setHamiltonianSimulationSlices
      - è®¾ç½®å“ˆå¯†é¡¿é‡æ¨¡æ‹Ÿåˆ‡ç‰‡æ•°
    * - setSaveDataDir
      - è®¾ç½®ä¸­é—´æ•°æ®å­˜æ”¾ç›®å½•
    * - setRandomPara
      - è®¾ç½®éšæœºä¼˜åŒ–å‚æ•°
    * - setDefaultOptimizedPara
      - è®¾ç½®é»˜è®¤ä¼˜åŒ–å‚æ•°
    * - setToGetHamiltonianFromFile
      - è®¾ç½®ä»æ–‡ä»¶è·å–ä½“ç³»å“ˆå¯†é¡¿é‡
    * - setHamiltonianGenerationOnly
      - è®¾ç½®åªç”Ÿæˆä½“ç³»å“ˆå¯†é¡¿é‡
    * - exec
      - æ‰§è¡Œè®¡ç®—
    * - getLastError
      - è·å–æœ€åä¸€æ¡é”™è¯¯æ—¥å¿—

â€ƒâ€ƒinitializeæ¥å£ï¼Œä½œç”¨æ˜¯ç”¨æ¥åˆå§‹åŒ–é‡å­åŒ–å­¦è®¡ç®—ç¯å¢ƒï¼Œå®ƒéœ€è¦ä¼ å…¥ä¸€ä¸ªå˜é‡å°±æ˜¯é‡å­åŒ–å­¦è®¡ç®—åŒ…çš„è·¯å¾„ï¼Œè¿™é‡Œå·²ç»æŠŠPSi4å®‰è£…åœ¨äº†pythonèƒ½æ£€ç´¢åˆ°çš„ç¯å¢ƒè·¯å¾„ä¸‹ï¼Œä½¿ç”¨æ—¶åªéœ€è¦ä¼ å…¥ç©ºçš„å­—ç¬¦ä¸²å³å¯ã€‚  ä¸‹é¢æ¼”ç¤ºä¸€ä¸‹å¦‚ä½•ä½¿ç”¨ChemiQè®¡ç®—æ¥å£æ¥å®ç°æ°¢åˆ†å­çš„åŸºæ€èƒ½é‡è®¡ç®—ã€‚

â€ƒâ€ƒé¦–å…ˆæ„é€ ä¸€ç»„ä¸åŒè·ç¦»ä¸‹çš„æ°¢åˆ†å­æ¨¡å‹ï¼›ç„¶åç”ŸæˆChemiQçš„ä¸€ä¸ªå®ä¾‹ï¼Œè°ƒç”¨setMoleculesæ¥å£è®¾ç½®ä¸€ç»„æ°¢åˆ†å­æ¨¡å‹ï¼Œè®¾ç½®æ°¢åˆ†å­çš„ç”µè·æ•°ä¸º0ï¼Œè‡ªæ—‹å¤šé‡åº¦ä¸º1ï¼›ä½¿ç”¨çš„è®¡ç®—åŸºæ˜¯sto-3gï¼›UCCæ¨¡å‹æˆ‘ä»¬ä½¿ç”¨çš„æ˜¯UCCSï¼Œè´¹ç±³å­å“ˆå¯†é¡¿é‡åˆ°æ³¡åˆ©å“ˆå¯†é¡¿é‡çš„è½¬æ¢è¿™é‡Œç”¨çš„æ˜¯JWå˜æ¢ï¼›è¿™é‡Œä½¿ç”¨çš„ä¼˜åŒ–å™¨æ˜¯Nelder-Meadï¼Œä¼˜åŒ–å™¨è¿­ä»£æ¬¡æ•°ä¸º200ï¼Œå‡½æ•°è°ƒç”¨æ¬¡æ•°ä¸º200ï¼Œæ˜¾ç¤ºä¼˜åŒ–å™¨è®¡ç®—çš„ä¸­é—´ç»“æœï¼›æœ€åæ‰§è¡Œè®¡ç®—ã€‚

.. code-block::

    1.import matplotlib.pyplot as plt  
    2.  
    3.from pyqpanda import *  
    4.  
    5.if __name__=="__main__":  
    6.  
    7.    distances = [x * 0.1 for x in range(2, 25)]  
    8.    molecule = "H 0 0 0\nH 0 0 {0}"  
    9.  
    10.    molecules = []  
    11.    for d in distances:  
    12.        molecules.append(molecule.format(d))  
    13.  
    14.    chemiq = ChemiQ()  
    15.    chemiq.initialize("")  
    16.    chemiq.setMolecules(molecules)  
    17.    chemiq.setCharge(0)  
    18.    chemiq.setMultiplicity(1)  
    19.    chemiq.setBasis("sto-3g")  
    20.    chemiq.setUccType(UccType.UCCS)  
    21.    chemiq.setTransformType(TransFormType.Jordan_Wigner)  
    22.    chemiq.setOptimizerType(OptimizerType.NELDER_MEAD)  
    23.    chemiq.setOptimizerIterNum(200)  
    24.    chemiq.setOptimizerFatol(200)  
    25.    chemiq.exec()  
    26.    chemiq.finalize()  
    27.      
    28.    value = chemiq.getEnergies()  
    29.  
    30.    plt.plot(distances , value, 'r')  
    31.    plt.xlabel('distance')  
    32.    plt.ylabel('energy')  
    33.    plt.title('VQE PLOT')  
    34.    plt.show()

â€‹â€ƒâ€ƒè·å–ä¼˜åŒ–åçš„èƒ½é‡ï¼Œç»˜åˆ¶æ›²çº¿å›¾ã€‚è¿™æ¡æ›²çº¿å°±æ˜¯ä¼˜åŒ–å¾—åˆ°çš„æ°¢åˆ†å­åœ¨ä¸åŒè·ç¦»ä¸‹å¯¹åº”çš„åŸºæ€èƒ½é‡ï¼š

.. image:: ./images/å›¾é™„3.1.16.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.3.1 æ°¢åˆ†å­åœ¨ä¸åŒè·ç¦»ä¸‹å¯¹åº”çš„åŸºæ€èƒ½é‡

3.4 éæ¢¯åº¦ä¸‹é™æ³•å®ç°VQEç®—æ³•ä»£ç ç¤ºä¾‹
==========================================

â€‹â€ƒâ€ƒé¦–å…ˆï¼Œå¯¼å…¥pyQPandaå’Œpsi4_wrapperä¸­çš„æ‰€æœ‰æ¨¡å—ï¼Œä»¥åŠä¸€äº›å…¶å®ƒç»„ä»¶æ¨¡å—å‡†å¤‡ã€‚

.. code-block::

  1.from pyqpanda import *  
  2.from psi4_wrapper import *  
  3.import numpy as np  
  4.from functools import partial  
  5.from math import pi  
  6.import matplotlib.pyplot as plt


â€‹â€ƒâ€ƒç„¶åï¼Œå®šä¹‰éæ¢¯åº¦ä¸‹é™ä¼˜åŒ–å™¨ä½¿ç”¨çš„æŸå¤±å‡½æ•°ä¸ºloss_funcï¼Œloss_funcæ¥å—çš„ä¸€ç»„å‚æ•°ä¸ºå¾…ä¼˜åŒ–çš„å‚æ•°åˆ—è¡¨ï¼Œè½¨é“ä¸ªæ•°ï¼Œç”µå­ä¸ªæ•°ï¼Œä½“ç³»å“ˆå¯†é¡¿é‡ã€‚è¿™ä¸ªæ¥å£æ˜¯å…ˆç”¨ccsdæ¨¡å‹æ„é€ çš„è´¹ç±³å­å“ˆå¯†é¡¿é‡ï¼Œç„¶ååˆ©ç”¨JWå˜æ¢å°†è´¹ç±³å­å“ˆå¯†é¡¿é‡è½¬æ¢ä¸ºæ³¡åˆ©å“ˆå¯†é¡¿é‡ï¼Œå†æ¥ç€å°†CCè½¬åŒ–æˆUCCï¼Œå†è®¡ç®—ä½“ç³»å“ˆå¯†é¡¿é‡åœ¨è¯•éªŒæ€ä¸‹çš„æœŸæœ›ï¼Œæœ€åè¿”å›æœŸæœ›å€¼æ¥å®ç°çš„ã€‚

.. code-block::

    1.def loss_func(para_list, qubit_number, electron_number, Hamiltonian):  
    2.    '''  
    3.    <ğœ“^âˆ—|ğ»|ğœ“>, Calculation system expectation of Hamiltonian in experimental state.  
    4.    para_list: parameters to be optimized  
    5.    qubit_number: qubit number  
    6.    electron_number: electron number  
    7.    Hamiltonian: System Hamiltonian  
    8.    '''  
    9.    fermion_cc =get_ccsd(qubit_number, electron_number, para_list)  
    10.    pauli_cc = JordanWignerTransform(fermion_cc)  
    11.    ucc = cc_to_ucc_hamiltonian(pauli_cc)  
    12.    expectation=0  
    13.    for component in Hamiltonian:  
    14.        expectation+=get_expectation(qubit_number, electron_number, ucc, component)  
    15.    expectation=float(expectation.real)  
    16.    print(expectation)  
    17.    return ("", expectation) Â 


â€‹â€ƒâ€ƒä¸‹é¢å°†å¯¹loss_funcä½¿ç”¨åˆ°çš„æ¥å£é€ä¸ªè¿›è¡Œè®²è§£ï¼š

â€‹â€ƒâ€ƒget_ccsd_n_termæ¥å£çš„ä½œç”¨æ˜¯è¿”å›æ„é€ CCSDæ¨¡å‹éœ€è¦ç”¨åˆ°çš„å‚æ•°ä¸ªæ•°ï¼Œè¿™ä¸ªæ¥å£æ¥æ”¶çš„å‚æ•°æ˜¯è½¨é“ä¸ªæ•°å’Œç”µå­ä¸ªæ•°ã€‚

.. code-block::

    1.def get_ccsd_n_term(qn, en):  
    2.    '''  
    3.    coupled cluster single and double model.  
    4.    e.g. 4 qubits, 2 electrons  
    5.    then 0 and 1 are occupied,just consider 0->2,0->3,1->2,1->3,01->23  
    6.    '''  
    7.  
    8.    if n_electron>n_qubit:  
    9.        assert False  
    10.      
    11.    return int((qn - en) * en + (qn - en)* (qn -en - 1) * en * (en - 1) / 4) 

â€‹â€ƒâ€ƒget_ccsdæ¥å£åˆ™æ˜¯ç”¨æ¥æ„é€ æ™®é€šå‚æ•°å¯¹åº”çš„CCSDæ¨¡å‹è´¹ç±³å­å“ˆå¯†é¡¿é‡ï¼Œè¯¥æ¥å£æ¥æ”¶çš„å‚æ•°æ˜¯è½¨é“ä¸ªæ•°ã€ç”µå­ä¸ªæ•°å’Œå•æ¿€å‘åŒæ¿€å‘å‰é¢å¯¹åº”çš„ç³»æ•°ã€‚

.. code-block::

    1.def get_ccsd(qn, en, para):  
    2.    '''  
    3.    get Coupled cluster single and double model.  
    4.    e.g. 4 qubits, 2 electrons  
    5.    then 0 and 1 are occupied,just consider 0->2,0->3,1->2,1->3,01->23.  
    6.    returned FermionOperator like this:  
    7.    { {"2+ 0":var[0]},{"3+ 0":var[1]},{"2+ 1":var[2]},{"3+ 1":var[3]},  
    8.    {"3+ 2+ 1 0":var[4]} }  
    9.  
    10.    '''  
    11.    if n_electron>n_qubit:  
    12.        assert False  
    13.    if n_electron==n_qubit:  
    14.        return FermionOperator()  
    15.  
    16.    if get_ccsd_n_term(qn, en) != len(para):  
    17.        assert False  
    18.  
    19.    cnt = 0  
    20.    fermion_op = FermionOperator()  
    21.    for i in range(en):  
    22.        for ex in range(en, qn):  
    23.            fermion_op += FermionOperator(str(ex) + "+ " + str(i), para[cnt])  
    24.            cnt += 1     
    25.      
    26.    for i in range(n_electron):  
    27.        for j in range(i+1,n_electron):  
    28.            for ex1 in range(n_electron,n_qubit):  
    29.                for ex2 in range(ex1+1,n_qubit):  
    30.                    fermion_op += FermionOperator(  
    31.                        str(ex2)+"+ "+str(ex1)+"+ "+str(j)+" "+str(i),  
    32.                        para[cnt]  
    33.                    )  
    34.                    cnt += 1  
    35.                      
    36.    return fermion_op  

â€‹â€ƒâ€ƒJordanWignerTransformæ¥å£çš„ä½œç”¨æ˜¯å°†è´¹ç±³å­å“ˆå¯†é¡¿é‡è½¬æ¢æˆæ³¡åˆ©å“ˆå¯†é¡¿é‡ã€‚

.. code-block::

    1.def JordanWignerTransform(fermion_op):  
    2.    data = fermion_op.data()  
    3.    pauli = PauliOperator()  
    4.    for i in data:  
    5.        pauli += get_fermion_jordan_wigner(i[0][0])*i[1]  
    6.    return pauliÂ 


â€‹â€ƒâ€ƒget_fermion_jordan_wigneræ¥å£åˆ™æ˜¯å°†è´¹ç±³å­å“ˆå¯†é¡¿é‡çš„å­é¡¹è½¬æ¢æˆæ³¡åˆ©å“ˆå¯†é¡¿é‡ã€‚

.. code-block::

    1.def get_fermion_jordan_wigner(fermion_item):  
    2.    pauli = PauliOperator("", 1)  
    3.  
    4.    for i in fermion_item:  
    5.        op_qubit = i[0]  
    6.        op_str = ""  
    7.        for j in range(op_qubit):  
    8.            op_str += "Z" + str(j) + " "  
    9.  
    10.        op_str1 = op_str + "X" + str(op_qubit)  
    11.        op_str2 = op_str + "Y" + str(op_qubit)  
    12.  
    13.        pauli_map = {}  
    14.        pauli_map[op_str1] = 0.5  
    15.  
    16.        if i[1]:  
    17.            pauli_map[op_str2] = -0.5j  
    18.        else:  
    19.            pauli_map[op_str2] = 0.5j  
    20.  
    21.        pauli *= PauliOperator(pauli_map)  
    22.  
    23.    return pauli   

â€‹â€ƒâ€ƒcc_to_ucc_hamiltonianæ¥å£çš„ä½œç”¨æ˜¯CCæ¨¡å‹å¯¹åº”çš„å“ˆå¯†é¡¿é‡è½¬æˆUCCæ¨¡å‹å¯¹åº”çš„å“ˆå¯†é¡¿é‡ã€‚

.. code-block::

    1.def cc_to_ucc_hamiltonian(cc_op):  
    2.    '''  
    3.    generate Hamiltonian form of unitary coupled cluster   
    4.    based on coupled cluster,H=1j*(T-dagger(T)),  
    5.    then exp(-iHt)=exp(T-dagger(T))  
    6.    '''  
    7.    return 1j*(cc_op-cc_op.dagger()) Â 


â€‹â€ƒâ€ƒget_expectationæ¥å£ï¼Œä½œç”¨æ˜¯è®¡ç®—ä½“ç³»å“ˆå¯†é¡¿é‡åœ¨è¯•éªŒæ€ä¸‹çš„æœŸæœ›ï¼Œæ¥æ”¶çš„å‚æ•°æ˜¯è½¨é“ä¸ªæ•°ï¼Œç”µå­ä¸ªæ•°ï¼ŒUCCæ¨¡å‹ï¼Œä½“ç³»å“ˆå¯†é¡¿é‡çš„ä¸€ä¸ªå­é¡¹ã€‚

.. code-block::

    1.def get_expectation(n_qubit, n_en, ucc,component):  
    2.    '''  
    3.    get expectation of one hamiltonian.  
    4.    n_qubit: qubit number  
    5.    n_en: electron number  
    6.    ucc: unitary coupled cluster operator  
    7.    component: paolioperator and coefficient,e.g. ('X0 Y1 Z2',0.2)  
    8.    '''  
    9.  
    10.    machine=init_quantum_machine(QMachineType.CPU)  
    11.    q = machine.qAlloc_many(n_qubit)  
    12.    prog=QProg()  
    13.  
    14.    prog.insert(prepareInitialState(q, n_en))  
    15.    prog.insert(simulate_hamiltonian(q, ucc, 1.0, 4))  
    16.      
    17.    for i, j in component[0].items():  
    18.        if j=='X':  
    19.            prog.insert(H(q[i]))  
    20.        elif j=='Y':  
    21.            prog.insert(RX(q[i],pi/2))  
    22.      
    23.    machine.directly_run(prog)  
    24.    result=machine.get_prob_dict(q, select_max=-1)  
    25.    machine.qFree_all(q)  
    26.      
    27.    expectation=0  
    28.    #å¥‡è´Ÿå¶æ­£  
    29.    for i in result:  
    30.        if parity_check(i, component[0]):  
    31.            expectation-=result[i]  
    32.        else:  
    33.            expectation+=result[i]         
    34.    return expectation*component[1]  

â€‹â€ƒâ€ƒprepareInitialStateæ¥å£çš„ä½œç”¨æ˜¯åˆ¶å¤‡åˆæ€ï¼Œæ¥æ”¶çš„å‚æ•°æ˜¯ä¸€ç»„é‡å­æ¯”ç‰¹å’Œç”µå­ä¸ªæ•°ã€‚

.. code-block::

    1.def prepareInitialState(qlist, en):  
    2.    '''  
    3.    prepare initial state.   
    4.    qlist: qubit list  
    5.    en: electron number  
    6.    return a QCircuit  
    7.    '''  
    8.    circuit = QCircuit()  
    9.    if len(qlist) < en:  
    10.        return circuit  
    11.  
    12.    for i in range(en):  
    13.        circuit.insert(X(qlist[i]))  
    14.  
    15.    return circuit;


â€‹â€ƒâ€ƒsimulate_hamiltonianæ¥å£ï¼Œä½œç”¨æ˜¯æ„é€ å“ˆå¯†é¡¿é‡çš„æ¨¡æ‹Ÿçº¿è·¯ï¼Œæ¥æ”¶çš„å‚æ•°æ˜¯ä¸€ç»„é‡å­æ¯”ç‰¹ï¼Œæ³¡åˆ©å“ˆå¯†é¡¿é‡ã€æ¼”åŒ–æ—¶é—´æ¼”åŒ–æ¬¡æ•°ã€‚

.. code-block::

    1.def simulate_hamiltonian(qubit_list,pauli,t,slices=3):  
    2.    '''  
    3.    Simulate a general case of hamiltonian by Trotter-Suzuki  
    4.    approximation. U=exp(-iHt)=(exp(-i H1 t/n)*exp(-i H2 t/n))^n  
    5.    '''  
    6.    circuit =QCircuit()  
    7.  
    8.    for i in range(slices):  
    9.        for op in pauli.data():  
    10.            term = op[0][0]  
    11.            circuit.insert(  
    12.                simulate_one_term(  
    13.                    qubit_list,   
    14.                    term, op[1].real,   
    15.                    t/slices  
    16.                )  
    17.            )  
    18.  
    19.    return circuit 


â€‹â€ƒâ€ƒsimulate_one_termæ˜¯æ„é€ å“ˆå¯†é¡¿é‡å­é¡¹çš„æ¨¡æ‹Ÿçº¿è·¯ã€‚

.. code-block::

    1.def simulate_one_term(qubit_list, hamiltonian_term, coef, t):  
    2.    '''  
    3.    Simulate a single term of Hamilonian like "X0 Y1 Z2" with  
    4.    coefficient and time. U=exp(-it*coef*H)  
    5.    '''  
    6.    circuit =QCircuit()  
    7.  
    8.    if not hamiltonian_term:  
    9.        return circuit  
    10.  
    11.    transform=QCircuit()  
    12.    tmp_qlist = []  
    13.    for q, term in hamiltonian_term.items():          
    14.        if term is 'X':              
    15.            transform.insert(H(qubit_list[q]))              
    16.        elif term is 'Y':  
    17.            transform.insert(RX(qubit_list[q],pi/2))                
    18.  
    19.        tmp_qlist.append(qubit_list[q])       
    20.  
    21.    circuit.insert(transform)  
    22.  
    23.    size = len(tmp_qlist)  
    24.    if size == 1:  
    25.        circuit.insert(RZ(tmp_qlist[0], 2*coef*t))  
    26.    elif size > 1:  
    27.        for i in range(size - 1):  
    28.            circuit.insert(CNOT(tmp_qlist[i], tmp_qlist[size - 1]))     
    29.        circuit.insert(RZ(tmp_qlist[size-1], 2*coef*t))  
    30.        for i in range(size - 1):  
    31.            circuit.insert(CNOT(tmp_qlist[i], tmp_qlist[size - 1]))    
    32.  
    33.    circuit.insert(transform.dagger())  
    34.  
    35.    return circuit


â€‹â€ƒâ€ƒpaity_checkæ˜¯å¯¹é‡å­æ€ä¸­æŒ‡å®šæ¯”ç‰¹1çš„ä¸ªæ•°åšå¥‡å¶æ ¡éªŒã€‚

.. code-block::

    1.def parity_check(number, terms):  
    2.    '''  
    3.    pairty check   
    4.    number: quantum state  
    5.    terms: a single term of PauliOperator, like"[(0, X), (1, Y)]"  
    6.    '''  
    7.    check=0  
    8.    number=number[::-1]  
    9.    for i in terms:  
    10.        if number[i]=='1':  
    11.            check+=1  
    12.    return check%2  


â€‹â€ƒâ€ƒoptimize_by_no_gradientæ˜¯éæ¢¯åº¦ä¸‹é™ä¼˜åŒ–ç®—æ³•çš„ä¸»ä½“æ¥å£ï¼Œéœ€è¦ä¼ å…¥çš„ä¸€ç»„å‚æ•°æ˜¯ä½“ç³»å“ˆå¯†é¡¿é‡ï¼Œè½¨é“ä¸ªæ•°ï¼Œç”µå­ä¸ªæ•°ï¼Œä¼˜åŒ–å™¨è¿­ä»£æ¬¡æ•°

â€‹â€ƒâ€ƒæ¥å£çš„å…·ä½“å®ç°æ­¥éª¤æ˜¯ï¼šé¦–å…ˆåˆå§‹åŒ–ä¸€ç»„å¾…ä¼˜åŒ–çš„å‚æ•°ï¼Œç„¶åæ„é€ ä¸€ä¸ªéæ¢¯åº¦ä¸‹é™ä¼˜åŒ–å™¨ï¼Œè¿™é‡Œæ„é€ çš„ä¼˜åŒ–å™¨æ˜¯Nelder-Meadï¼Œè®¾ç½®ä¼˜åŒ–å™¨çš„è¿­ä»£æ¬¡æ•°å¹¶å‘ä¼˜åŒ–å™¨æ³¨å†Œè®¡ç®—æœŸæœ›çš„æŸå¤±å‡½æ•°ï¼Œç„¶åæ‰§è¡Œä¼˜åŒ–å™¨ï¼Œæœ€åè¿”å›ä¼˜åŒ–å™¨ä¼˜åŒ–çš„æœ€ä½æœŸæœ›å€¼ã€‚

.. code-block::

    1.def optimize_by_no_gradient(mol_pauli, n_qubit, n_en, iters):  
    2.    n_para = get_ccsd_n_term(n_qubit, n_electron)  
    3.  
    4.    para_vec = []  
    5.    for i in range(n_para):  
    6.        para_vec.append(0.5)  
    7.  
    8.    no_gd_optimizer = OptimizerFactory.makeOptimizer(OptimizerType.NELDER_MEAD)  
    9.    no_gd_optimizer.setMaxIter(iters)  
    10.    no_gd_optimizer.setMaxFCalls(iters)  
    11.    no_gd_optimizer.registerFunc(partial(  
    12.        loss_func,   
    13.        qubit_number = n_qubit,   
    14.        electron_number = n_en,  
    15.        Hamiltonian=mol_pauli.toHamiltonian(1)),   
    16.        para_vec)  
    17.  
    18.    no_gd_optimizer.exec()  
    19.    result = no_gd_optimizer.getResult()  
    20.    print(result.fun_val)  
    21.  
    22.    return result.fun_val  


â€‹â€ƒâ€ƒetAtomElectronNumæ¥å£ä½œç”¨æ˜¯è¿”å›åŸå­å¯¹åº”çš„ç”µå­ä¸ªæ•°ã€‚

.. code-block::

    1.def getAtomElectronNum(atom):  
    2.    atom_electron_map = {  
    3.        'H':1, 'He':2, 'Li':3, 'Be':4, 'B':5, 'C':6, 'N':7, 'O':8, 'F':9, 'Ne':10,   
    4.        'Na':11, 'Mg':12, 'Al':13, 'Si':14, 'P':15, 'S':16, 'Cl':17, 'Ar':18  
    5.    }  
    6.  
    7.    if (not atom_electron_map.__contains__(atom)):  
    8.        return 0  
    9.  
    10.    return atom_electron_map[atom]  


â€‹â€ƒâ€ƒè¯¥ç®—æ³•æ¼”ç¤ºç¤ºä¾‹å¯¹åº”çš„ä¸»å‡½æ•°ï¼Œé¦–å…ˆæ„é€ ä¸€ç»„ä¸åŒè·ç¦»ä¸‹çš„æ°¢åˆ†å­æ¨¡å‹ï¼Œç„¶åè®¡ç®—æ¯ä¸ªæ°¢åˆ†å­æ¨¡å‹å¯¹åº”çš„åŸºæ€èƒ½é‡ï¼Œæœ€åå°†è®¡ç®—çš„ç»“æœç»˜åˆ¶æˆæ›²çº¿å›¾ã€‚

.. code-block::

    1.if __name__=="__main__":      
    2.    distances = [x * 0.1 for x in range(2, 25)]  
    3.    molecule = "H 0 0 0\nH 0 0 {0}"  
    4.  
    5.    molecules = []  
    6.    for d in distances:  
    7.        molecules.append(molecule.format(d))  
    8.  
    9.    chemistry_dict = {  
    10.        "mol":"",  
    11.        "multiplicity":1,  
    12.        "charge":0,  
    13.        "basis":"sto-3g",  
    14.    }  
    15.  
    16.    energies = []  
    17.  
    18.    for d in distances:  
    19.        mol = molecule.format(d)  
    20.  
    21.        chemistry_dict["mol"] = molecule.format(d)  
    22.        data = run_psi4(chemistry_dict)  
    23.        #get molecule electron number  
    24.        n_electron = 0  
    25.        mol_splits = mol.split()  
    26.        cnt = 0  
    27.        while (cnt < len(mol_splits)):  
    28.            n_electron += getAtomElectronNum(mol_splits[cnt])  
    29.            cnt += 4  
    30.  
    31.        fermion_op = parsePsi4DataToFermion(data[1])  
    32.        pauli_op = JordanWignerTransform(fermion_op)  
    33.  
    34.        n_qubit = pauli_op.getMaxIndex()  
    35.  
    36.        energies.append(optimize_by_no_gradient(pauli_op, n_qubit, n_electron, 200))  
    37.  
    38.    plt.plot(distances , energies, 'r')  
    39.    plt.xlabel('distance')  
    40.    plt.ylabel('energy')  
    41.    plt.title('VQE PLOT')  
    42.    plt.show()  


â€‹â€ƒâ€ƒè¯¥ç¤ºä¾‹å¯¹åº”çš„è¾“å‡ºç»“æœå¦‚ä¸‹ï¼Œæ›²çº¿å›¾æ˜¯æ°¢åˆ†å­åœ¨ä¸åŒè·ç¦»ä¸‹å¯¹åº”çš„åŸºæ€èƒ½é‡ï¼š

.. image:: ./images/å›¾é™„3.1.15.png
   :align: center
   :width: 500 px
.. centered:: å›¾é™„3.3.2 æ°¢åˆ†å­åœ¨ä¸åŒè·ç¦»ä¸‹å¯¹åº”çš„åŸºæ€èƒ½é‡